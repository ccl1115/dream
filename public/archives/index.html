<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Archives | Dream</title>
  <meta name="author" content="Simon Yu">

  
  <meta name="description" content="一个程序员的梦想">
  
  

  <link rel="alternate" href="/atom.xml" title="Dream" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
  
</head>

<body>
  <header id="header" class="inner"><nav>
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
</nav></header>
  <div id="content" class="inner">

<header id="archive-header">
  <h1 class="alignleft">Archives</h1>
  <div class="search alignright">
    <form action="http://google.com/search" method="get" accept-charset="utf-8">
      <input type="search" name="q" results="0" placeholder="Search">
      <input type="hidden" name="q" value="site:dream.yu-lu.info">
    </form>
  </div>
</header>


  
    <article class="post">
  
  <header>
    
  
    <h1 class="title"><a href="/2013/12/31/fisher-yates-shuffle/">Fisher-Yates shuffle</a></h1>
  

    <time datetime="2013-12-31T03:59:52.000Z">
  <span class="day">31</span><span class="month">Dec</span>
</time>
  </header>
  <div class="entry-content">
    
      <p>function shuffle(array) {<br>      var m = array.length, t, i;<br>      // While there remain elements to shuffle…<br>      while (m) {<br>        // Pick a remaining element…<br>        i = Math.floor(Math.random() * m—);<br>        // And swap it with the current element.<br>        t = array[m];<br>        array[m] = array[i];<br>        array[i] = t;<br>      }<br>      return array;<br>    }</p>

    
    
    <footer class="meta">
      
      
      
    </footer>
    
  </div>
  
</article>
  
    <article class="post">
  
  <header>
    
  
    <h1 class="title"><a href="/2013/12/31/guiprincipleandimplementation/">关于计算机图形界面的讨论</a></h1>
  

    <time datetime="2013-12-31T02:38:27.000Z">
  <span class="day">31</span><span class="month">Dec</span>
</time>
  </header>
  <div class="entry-content">
    
      <h1>第一章 历史</h1>
<h2>出现</h2>
<p>计算机接受我们的指令的这一过程，我们可以理解为输入，而这些指令的集合，我们可以称之为程序。当计算机把这些指令运行完毕之后，我们作为计算机的使用者，最关心的莫过于执行的结果。而计算机通过输出的方式，告诉我们一个程序的运行结果。</p>
<p>在计算机科学的发展过程中，我们放弃了直接把指令简单的输入给计算机的方式。我们发明的编程语言和相应的编译器来为我们生成复杂的，几乎无法直接由人类完成的指令集合，交由给计算机执行。然后当计算机执行完如此复杂的程序之后，它所得到的结果，必然也需要一种有效的方式输出给计算机的使用者。计算机在输入设备和输出设备上的发展是从来没有停止过的。在微软的体感设备Kinect的帮助下，人们已经可以通过简单的肢体动作来操作计算机执行程序。而苹果公司的Siri技术，已经可以通过模拟人类的语言来输出程序的运行结果。</p>
<p>但是从本质上来说，我们根本上能输入的还是编程语言产生的程序。而计算机产出的仅仅是数据而已。而在众多类型的程序中，有一种类型的程序被人使用得最多，而也正是这种类型的程序，让计算机得以在普通人之间流行开来。成为家家户户的必需品。这种程序的特性就是拥有图形界面。</p>
<p>70年代的时候，IBM认为未来的世界上，将只会有几台拥有超级计算能力的大型计算机。计算机使用者通过终端来访问和使用这些计算机。因为那时候，计算机被认为是只有计算机系的学生和老师，已经接受过专业训练的人才能被使用的设备。也许在现在听起来有些荒谬，但是以当时计算机的价格和其复杂的程度，这种观念确实是深入人心。</p>
<p>在今天看来，计算机之所以被大家使用，并不是因为它变小了，性能更强大了，或者是别的什么原因，而是因为它使用了图形化界面。任何计算机设备的流行，都要归功于当年推动图形化界面发展的公司。在这里我们最应该感谢的莫过于微软公司，是它推进了计算机的历史。尽管在Windows出现的十多年前，就有了带有图形界面的计算机，但是让计算机家喻户晓的，还是因为Windows和PC。</p>
<h2>典型</h2>
<p>在图形界面程序中，最具有影响力一款程序应该算是WinZip了－－一个算法开源的压缩程序的Windows版本。它是第一个带有工具栏和状态栏的图形界面程序，而今天不论是Mac或者PC上的任何一款程序，都沿用了这个形同于标准的特性。WinZip的界面布局甚至影响了Windows操作系统后来大部分程序的界面。正是WinZip告诉了世人，一个优秀图形界面程序就应该是这个样子。</p>
<h2>特性</h2>
<p>当我们面对图形界面的时候，我们不禁要问一问，到底是什么让图形界面程序被易于使用？曾经有人说过，图形界面的本质是点击，而操作计算机的本质是符号。图形界面之所以易于使用，是因为它把几乎有无限种可能的符号组合简化成了一些列系列的预定义的符号组合。如果每一种正确的组合能够完成一件特定的事情，那么使用图形界面的软件能够完成的事情是很有限的。当然通过多次基本符号组合的使用我们仍然可以完成更加复杂的符号组合才能完成的事情，但是效率上后者会高出很多来。</p>
<h3>VIM V.S. Notepad</h3>
<p>为了更好的解释图形界面的特性，本文特地用两个软件来进行一系列的比较。一个是命令行界面下经典的文本编辑器，而和它对比的是Windows系统下的经典文本编辑器Notepad。</p>
<p>我将列出一些列常用的针对文本操作的，它们可能是简单的操作，也可能是复杂的操作。</p>
<ul>
<li><p>从当前光标移动到下一个单词</p>
</li>
<li><p>移动到最后一行</p>
</li>
<li><p>在每一行之间再加入一个空行</p>
</li>
</ul>
<p>我们来看看两个程序各自是如何实现上面列出的操作的</p>
<pre><code>            <span class="title">VIM</span>                         Notepad</code></pre>
<hr>
<p>   1         \<esc\>w                使用鼠标点击下一个单词<br>   2    \<esc\>\<shift-g\>     拖动滚动条至底部，鼠标点击最后一行<br>   3   \<esc\>:%s/\n/\n\n    移动到每一行的结尾，输入一个回车</p>
<p>从上表中我们可以总结出一些规律。大部分的VIM操作是难以阅读的，我们甚至需要一些额外的学习来了解这些基本的操作是什么使用键盘来输入的。而大部分的Notepad操作使用人类语言就可以表述得足够明白。无论如何后者都更加的适用于普通人。也如同上面所描述的，VIM是用符号来操作，而Notepad多数是通过鼠标点击来完成的。</p>
<p>当然，我们应该肯定，后者的效率是远远低于前者的（Notepad的功能也非常的简单），但前者的学习成本是远远高于后者的。Notepad在处理一些复杂的操作的时候，需要反复的进行大量基本操作。简单总结起来，图形界面的要素就是使用基本并且简单的易于用人类语言描述的操作，并且操作大部分通过鼠标点击。正是这些特性，让人们更加喜欢使用图形界面，而不是记住那些晦涩的符号和它们对应的功能，甚至是在面对复杂操作的时候，使用大脑去设计出能够最高效的完成这个操作的符号组合。因为似乎普通人的大脑永远是懒惰的，或者说懒人才喜欢图形界面，再或者他们还没有遇到复杂到足以让他们使用智慧去创造更高效的符号组合的问题。总之无论如何，图形界面是简单的，易懂的，更是面向人类的。</p>
<h1>第二章 原理</h1>
<h2>如何在计算机中实现图形界面</h2>
<p>我们从计算机底层往上层说，想要图形界面，我们至少要具备的是一个显示器，当然还有一个显示芯片，当然计算机的雏形阶段，这些东西可不是必备的。接下来就是让我们能够操作显示芯片让显示器上显示东西的程序了，它一般被称为驱动，属于操作系统或者内核的一部分。有了驱动程序，我们能做的仅仅是最底层的操作。</p>
<p>在Linux系统中，操作驱动来为上层程序服务的东西叫显示服务（Display Server)，其中大名鼎鼎一个Display Server就是X，Unix，Linux，Mac这三个系统使用的都是X图形服务。那么它扮演的角色是什么呢？首先它对上层隐藏了硬件，如果我们直接使用驱动来绘制界面，一个最大的问题就是，每一种显示芯片的驱动可能是不同的。当我希望系统为我绘制一个圆形的时候，我可不希望自己写一个nvidia版本的，然后再写一个ati版本的，又或者是intel版本的，也有可能在没有硬件加速的情况下，我们使用的是CPU来为我们画这个圆形。总之，有了X，我们只要告诉它画一个圆，我们就会得到一个圆，至于它是如何操作硬件的，我们并不用关心。</p>
<p>我们知道Android系统是基于Linux的，那么它的显示服务是不是X呢？显然，对于一个手机来说，X过于庞大了；至少针对手机电量的问题，Android使用了自己独有的更加轻量级的显示服务，名为SurfaceFlinger。但是，无论如何，我们都需要一个显示服务来让上层的程序关注于绘制，而不是如何和不同的硬件打交道。</p>
<p>是不是有了X，我们就可以编写图形界面的程序了？确实是可以了，但是X为我们提供的还远远不够，X就像是一个画笔，我们从不能拿着画笔去画我们的图形界面程序。在传统的PC中，窗口的概念是非常重要的，但是在X中，是没有窗口的概念的。需要说明的是，这里的窗口并不是微软的那个操作系统。窗口是在X之上抽象出来的概念，我们可以简单地理解成，它是用来规划每一个图形界面程序的（当然，一个程序是完全可以拥有多个窗口的），它的理念让程序可以层叠，缩放，移动，隐藏。尽管没有它也可以编写图形界面，但是它的存在大大优化了用户在图形环境下的使用体验，同时对程序员来说，不用担心我们把自己的图形界面绘制到了别的应用程序中，毕竟如果去掉了窗口的抽象，所有程序共用一块屏幕的话，一定会引发一场不小的灾难的。</p>
<p>负责抽象出窗口的程序叫Window Manager（窗口管理器），在Linux下常见的有OpenBox，Awesome，XMonad等，那么KDE和GNOME不算窗口管理器么？准确的说，我们称它们为桌面环境（Desktop Environment），它们包含了窗口管理器，但是除了窗口管理器，它们还提供了更多的东西，主要是一些附带的功能性程序，比如浏览器，系统设定程序等等。</p>
<p>说到这里，一套完整的计算机图形界面架构也就完成了。尽管这里没有介绍Windows的架构，但也几乎和上面的相同，只不过Windows是一个非模块化的闭源系统，使得它不能像Linux或者Mac OS X一样可以很容易地选择不同的模块。比如在Mac上可以选择安装X后，使用XMonad作为窗口管理器，是的我们可以不使用Mac自带的Quartz。尽管Mac OS X是闭源的，但是它是模块化的。</p>
<p>对于程序员来说，我们还少了一个重要的部分，那就是图形界面的开发工具集。对于一个具备图形界面的操作系统来说，开发工具集是无关紧要的。它绝对不是一个操作系统的重要组成部分，但是对于程序员来说，没有它我们几乎很难直接写出图形界面的程序来。</p>
<h1>第三章 图形界面工具集</h1>
<h2>面向开发者的部分</h2>
<p>图形工具集到底为我们提供了什么特性，让我们能够轻松的开发图形界面程序呢？就像X为上层隐藏了硬件层一样，一个优秀的图形工具集会为图形界面程序隐藏很多下层的东西，当然并不是所有的图形界面工具集都是这样的。比如Java的SWT，你只能在JVM上使用它，但是使用Qt开发的程序可以运行在Windows，Linux，Android等系统上，也就是说，你不必关心你的系统环境，当然换句话说，运行于JVM上的SWT一样如此，理论上你可以在能运行JVM的任何操作系统上运行它。跨平台是一个优秀的工具集应该提供的的重要特性。</p>
<p>我们编写图形界面程序的时候，可能会需要到各种各样的元素。有时候我们需要显示一段文字，有时候我们需要显示一个按钮，一个下拉菜单，一个时钟，甚至是一个日历。我们希望工具集能给我们足够丰富的元素来满足我们的基本需求，而在我们有更高的需求的时候，工具集又能够为我们提供更多接近于显示服务给我们提供的API来绘制复杂的元素。</p>
<p>在创建这些元素的时候，它们包含了大量的默认属性，或者称之为样式，字体有默认的颜色，按钮有默认的背景，时钟指针使用了默认的贴图。工具集需要为我们提供一套处理样式的系统来，让我们可以自己创建一套样式集，或者称之为主题。并且这套系统能够灵活的处理样式的作用域，继承，组合等等问题。</p>
<p>在图形界面程序中的另一个重要部分就是资源的管理，不仅仅是简单地把资源文件存储起来，它必须满足的最重要的一点就是，能够根据不同的配置，或者不同的运行环境非常智能的为开发者提供合适的资源。这一点在早期的开发工具集中并没有得到很大的重视。但是随着工具集的运行时需要在很多不同的平台中上运行的时候，比如需要同时在手机或者电脑上运行的时候，这种特性显得尤为重要。我们可以举一个最简单的例子：桌面图标。当我们的应用在屏幕比较小的手机上运行的时候，我们需要一张小尺寸的图表资源；当我们在屏幕很大的手机上运行程序的时候，资源管理模块有责任为我们提供一个更大的图标资源。事实上，当近几年移动设备流行起来之后，对资源管理的需求就变得非常复杂起来。</p>
<p>在程序中加入图形界面之后，那么我们就会面临另一个相当重要的问题。那就是如何设计我们的图形界面，而比起传统的终端界面，图形界面显然需要被更精心的设计，毕竟要做到普通人能接受的良好交互，可能这并不是程序员擅长的。如果用从计算机的角度来设计图形用户界面，那么可能真的没有几个非程序员的用户愿意使用它。事实上，交互设计和界面设计是另一个行业的事情：设计行业。</p>
<p>在图形界面开发的早起，界面的元素的创建是在程序源代码里面的。这一点在今天几乎是不可接受的实现方式。这样的一个最大缺点就是，那些帮助我们设计程序界面和交互的人员无法参与真正地参与到界面的开发中。正是这样的问题，使得现在几乎所有流行的图形界面开发工具集都提供了专门用于描述界面样式和行为的外部语言。它们一般以xml之类的形式存在。尽管设计人员不能直接把Photoshop中的PSD设计文件直接简单地变成这种xml文件，但是通过简单的学习，他们就可以介入到编辑xml的工作中来。最重要的一点是，这种机制把界面和源码的开发分割开来，对开发人员来说，都是一件非常方便的事情：毕竟当用户界面变得很复杂的时候，用代码去创建上百个的界面元素，这其实是一样重复性非常高却完全不复杂的工作。</p>
<h2>空间中的元素</h2>
<p>图形界面的程序，不仅仅是在平面上的，甚至可能是在一个立体的世界里面。时下很多交互设计都加上了很多的3D变换。如果说我们把这个空间内的一个窗口称作一个程序，这个程序里面又会有很多的控件，随着时间的变化，它们的位置，形状都会发生改变。我们可以把每个具有大小，位置的东西称作一个元素，那么如何有效地规划这些元素，就成了图形界面工具集需要提供的最重要的功能。当我们使用工具集为我们提供的最简单的控件的时候，这里面都可能包含了很多的元素，而一个复杂的控件，必然是有很多个基本控件组成的。当我们组合了多个控件组的时候，得到可能就是一个具有完成功能的窗口，而不论是窗口，控件组，控件和基本元素，它们的共同特点就是大小和位置，而进一步，在一些强调复杂交互的工具集里，还提供了偏转位移，缩放，旋转等等属性。</p>
<p>如上面所说的，我们把所有存在于空间中具有大小和位置的对象成为元素。那么即便是一个复杂的窗口，它也可以被当作一个元素的看待。但是当我们移动这个窗口的时候，整个窗口内所有的元素都发生了位置上的变化。我们作为开发人员，肯定不能够在改变窗口位置的同时，去改变我们所有的内部元素位置。所以一个足够完善的图形界面开发工具集必须提供元素之间的相对操作，如果我们元素中的元素这种看作是父与子的关系，那么这种位置的变化就是相对的。一个在大部分情况下并不需要知道它位于屏幕中的绝对位置，除非它是一个窗口元素，但是本着一致性的原则，我们仍然需要把窗口元素的位置作为一个相对位置来处理。因为我们不能不考虑有时候我们的工具集能操作的显示屏幕并不一定对应了我们电脑的物理屏幕显示屏。事实上一个实际的例子就是Android系统在3.0之后加入的虚拟按键，它占用了屏幕下方的位置来模拟真正的物理按键。而如果Android工程师在一开始没有考虑到元素相对位置的一致性，那么他们不但给自己带来了问题，还给应用开发者造成了困扰。</p>
<p>那么我们到底需不需要绝对于屏幕的位置呢？我们永远不需要。为什么我们不需要呢？如果开发过图形界面程序的程序员，都了解大部分的工具集都提供了获得绝对位置的能力。这一点并没有错，很多时候，我们需要在我们窗口的外部显示一些控件。比如我们需要弹出一个位于屏幕左上角的提示信息的时候，我们显然不能以相对于我们程序主窗口的位置去计算我们的提示信息。但是如果把这种相对于桌面的相对位置理解成一种绝对位置是不准确的。在Mac OS X和很多Linux发行版中，桌面是可以被放大或者缩小的。我们并没有使用绝对的位置，只不过我们采用了桌面这个元素来作为我们的参考系而已。毕竟桌面也是一个程序，它也可以被视为一个元素。</p>
<p>相对性是很重要的，但是人们在一开始往往更加重视绝对性。当我们理解了使用了相对位置给我们带来的好处之后，一个元素的大小又何尝不能遵循同样的原理呢？如果窗口变大了，那么没有理由附属于其内部的所有元素都跟着一起变大。不过事实上，在大小上，元素往往不是相对的。当一个文本编辑器的窗口变大之后，编辑器并不会改变里面的文字的大小。我们缩放窗口往往只是为了看到更多的文字。</p>
<p>虽然听起来，这样的逻辑没有错误，但是我们却误解了元素的大小的真正含义。当我放大窗口的时候，我的确使得窗口的大小改变了，但是和把一张图片放大一倍的操作相比，它们是完全不一样的操作。我们实际上改变了编辑框的大小，但是我们并没有改变它的缩放值；当我们放大图片的时候，我们改变的是它的缩放值，而并非它的大小。前者应该被理解成一种裁剪，可以放大的裁剪。</p>
<h2>时间因素</h2>
<p>如果没有时间，那么就不会发生空间上的任何连续改变，尽管在计算机中，我们可以做到离散的元素位置变换，但是这样的事实确实完全和现实违背。我们希望图形界面中的任何东西都是线性移动的，而不是离散的变化，否则所有的东西都在跳跃。但是不得不说，大部分的图形界面工具集都不太重视这个部分的实现。因为计算机本质上就是离散的，从0到1之间没有任何其他东西。所以我们所看到的任何图形界面上的元素位置或大小的线性变化，在微观上来说都是有巨大的间隔的。</p>
<p>我们看电影，当画面每秒钟更新24次以上，人的眼睛就很难观察到胶片的离散变化了。但是在非常进距离，并且仔细观察的情况下，计算机每秒至少要更新60次才能做到完美的线性。人眼完全不能分辨出任何的跳跃。如果我们把一个元素从100像素改变成220像素，在没有动画的情况下计算机只需要进行一次计算。如果我们以每秒60像素的速度把一个元素从100像素动画到220像素，那么事实上，我们进行了120次改变大小的计算。后者的运算量是前者的120倍，仅仅是因为多了一个简单的动画。所以说，看似简单的动画，会成倍地增加计算量。</p>
<p>而随着这种计算量的爆炸式增加，我们如何能保证计算机能够在规定的时间内完成这些计算。因为计算120次并不难，但是如果必须要在2秒钟之后完成，恐怕就不是世界上所有的计算机都能胜任这一工作的了。但是我们要做的是让更多的计算机能够完成这一任务，而不是盲目的使用性能更高的计算器。</p>
<h2>硬件加速</h2>
<p>在图形界面系统中使用硬件加速，这方面做得最好的莫过于苹果公司了。苹果的闭源某种程度上来说，不仅仅是代码没有开放，更主要的是一种封闭的软件生态系统。在Unix哲学体系中，最主要的一条就是，不要为了提升性能和效率而使用硬件的特性。这一点，苹果公司从来没有遵守，因为从硬件到软件，几乎都是它自己生产的，即便今天很多硬件已经不是苹果生产的了，但是它从来没有给消费者选择硬件的机会。正式这一点使得它可以把硬件加速发挥到极致。所谓硬件加速，很简单，就是对于某些特别的事务，使用特定的芯片，而非通用的CPU指令来完成。一块300块钱的视频采集卡，其对视频处理的能力比目前最好的CPU的处理能力还要快10倍，后者的价格几乎是前者的20倍。至于为什么会有这样的结果，请参考《计算机组成与原理》一书。在动画上面，严格来说，在图形界面的绘制上面，苹果公司的软件都充分地利用了显卡来为其做渲染工作。因为对于苹果来说，它的产品永远只会使用一种硬件。而闭源的Windows也做不到这一点，更不要说Unix／Linux了，它们从来不挑硬件，光是CPU它们就支持10多种。</p>
<p>在今天的各种图形界面工具集中，只要是多平台的，它们几乎都不能良好地支持硬件加速。但是那些系统绑定的工具集往往都会提供硬件加速，但是因为这些系统往往需要在各种各样的硬件下工作，但是它们并不能提供一个足够完美的带有硬件加速的图形界面工具集。而只有苹果公司，在它创造的如此完美的但是又如此封闭的生态中，提供了非常完美的硬件加速。但是也正式因为目的性的不同，才造成了Mac系统或者iOS系统和其他系统的差异。</p>
<p>在某些特定的情况下，整个图形界面程序可能都是运行在显卡上的。它已经不能称之为硬件加速，而根本就是把CPU从整个绘制系统中给彻底去掉了。所有的游戏就是这样的，而且个别的程序也是这样的。当动画在整个程序中占有最重要的位置的时候，这确实是一个理想的选择。而且随着越来越多的跨平台游戏引擎的出现，这样的程序或者说游戏能够很方便地就运行在各种平台上。</p>
<h2>工具集的心脏</h2>
<p>当我们在图形界面程序中创建了一些的元素之后。一个最重要的工作就是渲染了。所谓的渲染可以理解为数据的可视化过程。大量位于内存中的元素，它们有自己的大小和位置属性，如果是文本元素，那么内存中会存有文本，而图片元素自然会存储图片。如何高效的把这些元素变成屏幕上真正可见的像素点集，这是一个并不简单的过程。我们会遇到很多可以优化的地方，比如那些被暂时隐藏了的元素，我们可以直接跳过它们地渲染过程；某些元素中被遮盖的部分，因为用户对其不可见，我们不需要去渲染；当一个元素更新了位置，我们只需要渲染它之前所在的区域和它下一次即将出现的区域，而不是渲染整个屏幕；当一个元素的位置表明它已经不在它父亲的可见范围的时候，我们也不需要去渲染那一部分。总之，内存中的任何一个元素中的任何一个影响到屏幕中实际显示的属性的变化都会触发一次新的渲染请求，而渲染器必须以最高效的方式来渲染它。</p>
<h3>被动渲染</h3>
<p>当一个界面在没有任何更新的时候，我们是不需要去渲染它的。也就是说，除非渲染器被告知需要渲染，那么才会触发一次新的渲染。而且渲染器是在无状态的模式下工作的，也就是说，每一次渲染和上一次或者下一次渲染都不会有任何的关联。每一次所需要渲染的区域是被别的模块告知的，因为图形界面工具集会在内部处理每次元素变化所导致的区域改变。</p>
<p>被动式渲染的好处有很多，但是也有它的适用范围，在图形界面程序中，它被认为是一种最佳实践。但是没有任何一款游戏是使用被动渲染的方式来制作游戏的。当渲染的内容几乎在每一个时刻都变化的情况下，主动渲染是更好的解决方案。主动渲染往往是在层次上作为优化的切入点，而不是像被动渲染这样采用尽量减少渲染区域的做法。</p>
<h3>界面的驱动</h3>
<p>前面我们简单介绍过显示服务这一概念。它的主要特性就是向上层隐藏了硬件。如果一个图形界面工具集的是针对单一系统的，那么它只需要基于一种显示服务来开发。但是大部分的图形工具集都是跨平台的，那么显然它们也必须要支持不同的显示服务。图形工具的开发者们当然可以这样做，他们为一种显示服务程序编写多个渲染器，从而在不同的系统上渲染我们的元素。</p>
<p>显然这样做显得并不太合理，除非是在一个闭源的环境下。市面上已经有一些社区是专门做这种渲染器的，它们可以在不同的环境下渲染图形。比如近年来被Google的两个最重要的产品所使用的skia，它能基于Bitmap，OpenGl，PDF等后台来渲染图形。而这两个产品分别是Android操作系统和Chrome浏览器。作为一个2D图形库，它可以在Android，iOS，Linux，Mac和Windows上使用。在这样的工具库的帮助下，我们可以很容易地开发跨平台的图形界面工具集，它让我们很容易地就脱离了操作系统，或者说是显示服务的限制。</p>
<h2>线程和同步</h2>
<p>我们几乎在任何一个图形界面工具集中都能找到消息系统和循环队列。因为在图形界面中，有一个需要被解决的最重要的问题就是阻塞。当我们读取文件，访问网络的时候，我们的系统就会变得非常的慢。因为无论我们有多快的CPU和内存，把外部的数据读取进来的时间都要比处理它们的时间慢了千万倍，这一点也不夸张。等待200毫秒才能得到网络上的图片这很正常，但是我们的图形界面是等不了这么多时间的。我们不能在这200毫秒的时间内让渲染器停止工作，就算这200毫秒可以被接受，那如果我们需要解压缩一个10GB的压缩文件呢？因为不同于命令行界面，图形界面必须是即刻响应的，我们不能让鼠标突然停止，让进度条卡在那里，让视频突然停在某一帧。为了解决这个问题，一个最简单有效解决的方式就是使用线程。</p>
<p>使用线程没有错，可是还不足以解决很多问题。当一场耗时操作完成时，或者是在耗时操作完成了一定百分比的时候，我们立刻需要更新我们的元素，然后工具集计算这些被更新的元素所影响到的屏幕区域，然后渲染器去渲染这些区域。这很简单，每间隔一定的时间，我们的界面得到一个更新的通知，然后负责渲染的线程执行渲染器的代码。</p>
<p>可是当事情稍微变得复杂一些的时候，如果我们同时解压缩10个文件，我们会在10个线程里面在操作，如果我们在一个线程中解压这10个文件，那么在图形界面上，一次渲染只会改变其中的一个进度条。但是即便在十个线程中分别解压，但每个线程完成了一部分任务并向负责渲染的线程发出通知的时候，它每接受到一个通知，立刻执行一次渲染绘制，如果在上一次渲染没有执行完成的时候，下一次的通知对顺序的执行。这样仍然不能解决每次只能更新一个进度条的问题。除非这十个线程约定好在同一个时间，把它们的所有信息集合成一个通知发送给渲染器线程。但是面对不同的实际问题，我们都必须设计一套高效的通知机制。</p>
<p>这样的通知方式设计得实在是太脆弱了。如果我们的渲染器是在模拟一场大雪呢？当通知从四面八方到来的时候，可能是网络请求，可能是用户输入，可能是加载图片的线程，当图形界面足够复杂的时候，这种简单的线程间的通知是不能满足需求的。</p>
<p>图形界面程序在运行起来的时候，在它的渲染线程中，其实是有一个循环的，这个循环去遍历一个队列，这个队列会不停被别的线程插入需要修改元素属性的代码。当然这种方式看起来简单，实现起来，却有很多可以被优化的地方。如果它只是简单的执行队列中一个一个的代码段，那么事实上，上面的多个线程通知绘制线程来触发渲染的问题仍然没有解决。试试上，处理完队列中的一个请求（代码段）之后，这个循环系统不会立刻要求渲染器进行渲染。图形界面系统每隔一个固定的时间才会去通知一次渲染器。</p>
<p>没错，渲染器必须在同步的情况下才能正确工作。当渲染器工作的时候，它不希望还有别的线程去不停的修改图形界面中元素的属性。因为渲染可能不仅仅只对元素集合做一次遍历。如果在一次渲染工作中，两次遍历的同一个元素的属性不一致，这个时候画出来的东西不可能是你希望得到的东西。这也是为什么大部分的图形界面工具集限制了在非渲染线程操作界面元素的原因。而循环系统在渲染器工作的时候可能会暂时停下来，因为在有些系统的设计中渲染器和循环并不在一个线程内工作，这又是一种更加复杂的同步机制了。</p>
<h1>第四章 总结</h1>
<p>在图形界面的发展中，还有很多的细节可以讨论，但是基本的原理无非是上面提到的这些。在很多的平台中，图形界面工具集只是其中很小的一部分，而随着图形工具集的发展，它们本身会提供很多方便开发图形界面程序的库，比如优化的线程系统，信号（订阅／发布）系统，数据和对象（元素）绑定，它们并不能算图形工具集的核心。另外在图形界面系统中，输入系统也是一个比较重要的部分。随着移动设备的流行，很多工具集都提供了响应触摸的API。</p>
<p>对于一个面向非程序员的程序，良好的界面和交互一直都是一个非常重要的部分。所以对于开发者来说，还是有必要了解其原理和实现的，本文仅仅是抛砖引玉，简单介绍了在图形系统中的几个重要部分，帮助读者以后做进一步的学习和研究的。</p>

    
    
    <footer class="meta">
      
      
      
    </footer>
    
  </div>
  
</article>
  
    <article class="post">
  
  <header>
    
  
    <h1 class="title"><a href="/2013/12/22/hello-world/">Hello World</a></h1>
  

    <time datetime="2013-12-21T19:38:27.000Z">
  <span class="day">22</span><span class="month">Dec</span>
</time>
  </header>
  <div class="entry-content">
    
      <p>这是一个使用Hexo搭建的静态博客系统。搭建它的目的是为了在平时工作中，学习中，把积累的东西记录下来。另外也尝试写一些随笔，对自己的生活发发牢骚。尽管这是我第n次搭建博客，我仍然希望这一次能够坚持把这个博客写下去。</p>

    
    
    <footer class="meta">
      
      
      
    </footer>
    
  </div>
  
</article>
  

  <nav id="pagenavi">
  
  
  <div class="clearfix"></div>
</nav>
</div>
  <footer id="footer" class="inner"><div class="social alignright">
  
  
  
  
  <a class="rss" href="/atom.xml" title="RSS">RSS</a>
</div>
<p>
  
  &copy; 2013 Simon Yu
  
</p>
<div class="clearfix"></div></footer>
  <script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


<div id="phasebeam">
  <canvas></canvas>
  <canvas></canvas>
  <canvas></canvas>
</div>
<script src="/js/phasebeam.js"></script>
</body>
</html>